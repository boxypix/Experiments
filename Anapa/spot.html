<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Анапа — прогноз + новости о мазуте</title>

  <link
    href="https://unpkg.com/maplibre-gl@4.0.2/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <script
    src="https://unpkg.com/maplibre-gl@4.0.2/dist/maplibre-gl.js"
    defer
  ></script>

  <style>
    :root{
      --bg:#0f1320;
      --card:#151a27;
      --text:#d7dcec;
      --muted:#9aa3bd;
      --line:#232a41;
      --accent:#6aa6ff;
      --ok:#62d26f;
      --warn:#ffb020;
      --bad:#ff5a6a;
      --radius:14px;
      --pad:16px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--font);
      background:linear-gradient(180deg, #0b1020 0%, var(--bg) 100%);
      color:var(--text);
    }
    header{
      padding:22px var(--pad) 8px;
      max-width:1100px;
      margin:0 auto;
    }
    h1{margin:0 0 6px; font-size:34px; font-weight:700}
    .sub{color:var(--muted); font-size:13px}
    .wrap{max-width:1100px; margin:0 auto; padding:12px var(--pad) 40px}
    .grid{display:grid; gap:14px}
    .card{
      background:rgba(21,26,39,.92);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:14px;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
    }
    #map{height:340px; border-radius:12px; overflow:hidden; position:relative}
    #tileCanvas{
      position:absolute;
      top:0;
      left:0;
      width:100%;
      height:100%;
      pointer-events:none;
      z-index:1;
      border-radius:12px;
    }
    .poiDot{width:8px; height:8px; border-radius:999px; background:#ff3b30; box-shadow:0 0 0 2px rgba(0,0,0,.35)}
    .poiLabel{
      margin-left:8px;
      font-size:14px;
      font-weight:600;
      color:#ffffff;
      /* обводка: чёрная с прозрачностью 0.5 */
      -webkit-text-stroke: 1px rgba(15, 15, 15, 0.5);
      /* fallback, если stroke не поддерживается */
      text-shadow:
        1px 0 rgba(0,0,0,.5),
        -1px 0 rgba(0,0,0,.5),
        0 1px rgba(0,0,0,.5),
        0 -1px rgba(0,0,0,.5);
    }
    .poiWrap{display:flex; align-items:center}
    .vaneBox{
      position:absolute;
      top:10px;
      left:10px;
      z-index:2;
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
    }
    .vaneArrowWrap{
      width:28px;
      height:28px;
      display:grid;
      place-items:center;
    }
    .vaneArrow{
      width:20px;
      height:20px;
      display:block;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,.6));
      transform-origin: 50% 50%;
      transform: rotate(0deg);
      user-select:none;
      pointer-events:none;
    }
    .vaneText{display:flex; flex-direction:column; line-height:1.1}
    .vaneLabel{font-size:12px; font-weight:400; color:var(--muted)}
    .vaneValue{font-size:16px; font-weight:800; color:var(--text)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      border:1px solid var(--line);
      padding:8px 10px;
      border-radius:999px;
      background:rgba(0,0,0,.15);
      color:var(--muted);
      font-size:12px;
    }
    .pill b{color:var(--text); font-weight:700}
    .controls{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px
    }
    input[type="text"]{
      width:min(680px,100%);
      padding:10px 12px;
      border-radius:10px;
      border:1px solid var(--line);
      outline:none;
      background:rgba(0,0,0,.22);
      color:var(--text);
    }
    button{
      padding:10px 12px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(106,166,255,.12);
      color:var(--text);
      cursor:pointer;
      font-weight:700;
    }
    button:hover{border-color:rgba(106,166,255,.5)}
    .hint{color:var(--muted); font-size:12px; margin-top:8px; line-height:1.45}
    .status{margin-top:10px; color:var(--muted); font-size:12px}
    .status.ok{color:var(--ok)}
    .status.warn{color:var(--warn)}
    .status.bad{color:var(--bad)}

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.12);
    }
    thead th{
      text-align:left;
      font-size:12px;
      color:var(--muted);
      padding:10px 12px;
      background:#11172a;
      border-bottom:1px solid var(--line);
      font-weight:700;
    }
    tbody td{
      padding:10px 12px;
      border-bottom:1px solid rgba(35,42,65,.65);
      font-size:13px;
    }
    tbody tr:last-child td{border-bottom:none}
    .mono{font-variant-numeric:tabular-nums}

    .loadingText{
      font-size:24px;
      font-weight:700;
      animation:loadingPulse 1s ease-in-out infinite;
    }
    @keyframes loadingPulse{
      0%{opacity:1}
      50%{opacity:.5}
      100%{opacity:1}
    }

    .statsRow{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:10px;
      align-items:stretch;
      margin-top:12px;
    }
    @media (min-width: 860px){
      .statsRow{ grid-template-columns: repeat(4, minmax(0, 1fr)); }
    }
    .statCard{
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(0,0,0,.14);
      padding:10px 12px;
    }
    .statLabel{font-size:12px; font-weight:400; color:var(--muted); line-height:1.2}
    .statValue{margin-top:6px; font-size:32px; font-weight:800; line-height:1}
    .statUnit{font-size:14px; font-weight:700; color:var(--muted); margin-left:6px}
    .news{
      display:grid;
      gap:10px;
      margin-top:10px;
    }
    .news a{
      color:var(--text);
      text-decoration:none;
    }
    .news a:hover{color:var(--accent)}
    .newsItem{
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(0,0,0,.14);
    }
    .newsItem .t{font-weight:700; line-height:1.35}
    .newsItem .m{margin-top:6px; color:var(--muted); font-size:12px}
    footer{max-width:1100px; margin:0 auto; padding:0 var(--pad) 22px; color:var(--muted); font-size:12px}
  </style>
</head>

<body>
  <header>
    <h1>Анапа — обстановка</h1>
    <div class="sub">Карта сверху, прогноз на 6 дней, новости RSS по мазуту.</div>
  </header>

  <div class="wrap grid">
    <!-- MAP -->
    <section class="card">
      <div class="row">
      </div>
      <div class="statsRow" aria-label="Погода сейчас">
        <div class="statCard">
          <div class="statLabel">Воздух</div>
          <div class="statValue"><span id="nowAirTemp" class="mono">—</span><span class="statUnit">°C</span></div>
        </div>
        <div class="statCard">
          <div class="statLabel">Ветер</div>
          <div class="statValue"><span id="nowWind" class="mono">—</span><span class="statUnit">м/с</span></div>
        </div>
        <div class="statCard">
          <div class="statLabel">Порывы</div>
          <div class="statValue"><span id="nowGust" class="mono">—</span><span class="statUnit">м/с</span></div>
        </div>
        <div class="statCard">
          <div class="statLabel">Температура воды</div>
          <div class="statValue"><span id="nowWater" class="mono">—</span><span class="statUnit">°C</span></div>
        </div>
      </div>
      <div id="map" style="margin-top:12px">
        <canvas id="tileCanvas"></canvas>
        <div class="vaneBox" id="windVane" aria-label="Флюгер ветра">
          <div class="vaneArrowWrap"><img class="vaneArrow" id="windVaneArrow" src="./arrow.svg" alt="" /></div>
          <div class="vaneText">
            <div class="vaneLabel">Ветер</div>
            <div class="vaneValue"><span id="windVaneDeg" class="mono">—</span>°</div>
          </div>
        </div>
      </div>
      <div class="status" id="mapStatus" style="margin-top:10px">—</div>
      <div class="hint">
        Карта — MapLibre GL JS. Стиль берётся из локального файла <span class="mono">map1.json</span> (рядом с <span class="mono">spot.html</span>).
      </div>
    </section>

    <!-- FORECAST -->
    <section class="card">
      <div class="row" style="justify-content:space-between">
        <div>
          <div style="font-weight:800; font-size:24px">Прогноз на сегодня <br>+ 5 дней</div>
          <div class="hint">Ветер/порывы/температура воздуха + (если доступно) температура воды.</div>
        </div>
        <button id="btnRefresh">Обновить</button>
      </div>

      <div class="status" id="wxStatus">—</div>

      <div style="margin-top:10px; overflow:auto">
        <table>
          <thead>
            <tr>
              <th>День</th>
              <th>Воздух, °C (min–max)</th>
              <th>Ветер, м/с (max)</th>
              <th>Порывы, м/с (max)</th>
              <th>Вода, °C (ср.)</th>
            </tr>
          </thead>
          <tbody id="wxTbody">
            <tr><td colspan="5" class="mono loadingText" style="color:var(--muted)">Загрузка…</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- RSS -->
    <section class="card">
      <div style="font-weight:800; font-size:24px">Новости о мазуте (RSS)</div>
      <div class="controls">
        <input id="rssQuery" type="text" value="мазут Анапа Краснодар" readonly />
        <button id="btnNews" style="display:none">Обновить новости</button>
      </div>
      <div class="hint">
        Новости берутся из файла <span class="mono">news_cache.json</span>, который обновляется GitHub Actions раз в 24 часа.
        Поэтому страница не ходит в RSS напрямую (нет проблем с CORS/прокси).
      </div>

      <div class="status" id="newsStatus">—</div>
      <div class="news" id="newsList"></div>
    </section>
  </div>

  <footer>
    Подсказка: чтобы уменьшить нагрузку на источники, можно добавить кеширование (например, через Cloudflare Worker).
  </footer>

  <script>
    // ====== НАСТРОЙКИ (Анапа) ======
    const PLACE = "Анапа";
    const LAT = 44.894;     // примерно центр Анапы
    const LON = 37.316;

    // POI точки (добавляй новые элементы сюда)
    // lat / lon — координаты, label — подпись
    const POIS = [
      { lat: 44.8917273, lon: 37.2963998, label: "Пляж" },
    ];

    // Open-Meteo (погода) — daily на 6 дней
    const WX_URL =
      "https://api.open-meteo.com/v1/forecast" +
      `?latitude=${LAT}&longitude=${LON}` +
      "&timezone=Europe/Moscow" +
      "&forecast_days=6" +
      "&daily=temperature_2m_max,temperature_2m_min,windspeed_10m_max,windgusts_10m_max" +
      "&hourly=temperature_2m,windspeed_10m,windgusts_10m,winddirection_10m";

    // Open-Meteo (море) — sea surface temperature hourly, потом сведём в среднее по дням
    // Если у Open-Meteo Marine что-то поменяется, просто отключится вода (код это переживёт).
    const MARINE_URL =
      "https://marine-api.open-meteo.com/v1/marine" +
      `?latitude=${LAT}&longitude=${LON}` +
      "&timezone=Europe/Moscow" +
      "&forecast_days=6" +
      "&hourly=sea_surface_temperature";


    // ====== УТИЛИТЫ ======
    const fmtDay = (isoDate) => {
      // isoDate: YYYY-MM-DD
      const d = new Date(isoDate + "T00:00:00");
      return d.toLocaleDateString("ru-RU", { weekday: "short", day: "2-digit", month: "2-digit" });
    };

    const mean = (arr) => {
      if (!arr || arr.length === 0) return null;
      let s = 0;
      for (const x of arr) s += x;
      return s / arr.length;
    };

    function nearestTimeIndex(times, nowMs) {
      // times: array of ISO strings (e.g., 2026-01-08T12:00)
      if (!times || times.length === 0) return -1;
      let bestI = 0;
      let bestD = Infinity;
      for (let i = 0; i < times.length; i++) {
        const ms = Date.parse(times[i]);
        if (!Number.isFinite(ms)) continue;
        const d = Math.abs(ms - nowMs);
        if (d < bestD) {
          bestD = d;
          bestI = i;
        }
      }
      return bestI;
    }

    function setNowValue(id, v, digits = 0) {
      const el = document.getElementById(id);
      if (!el) return;
      if (v === null || v === undefined || Number.isNaN(v)) {
        el.textContent = "—";
        return;
      }
      el.textContent = Number(v).toFixed(digits);
    }

    function setWindVane(deg) {
      const degEl = document.getElementById("windVaneDeg");
      const arrowEl = document.getElementById("windVaneArrow");
      if (!degEl || !arrowEl) return;

      if (deg === null || deg === undefined || Number.isNaN(deg)) {
        degEl.textContent = "—";
        arrowEl.style.opacity = "0.35";
        arrowEl.style.transform = "rotate(0deg)";
        return;
      }

      const d = ((Number(deg) % 360) + 360) % 360;
      degEl.textContent = d.toFixed(0);
      arrowEl.style.opacity = "1";
      // Поворачиваем стрелку на градусы направления ветра (как в данных источника)
      arrowEl.style.transform = `rotate(${d}deg)`;
    }

    function renderNowStats(wxJson, marineJsonOrNull) {
      const nowMs = Date.now();

      // air + wind + gust from Open-Meteo hourly
      const h = wxJson?.hourly;
      if (h?.time?.length) {
        const i = nearestTimeIndex(h.time, nowMs);
        const windSpeed = h.windspeed_10m?.[i];
        const windDir = h.winddirection_10m?.[i];
        
        setNowValue("nowAirTemp", h.temperature_2m?.[i], 0);
        setNowValue("nowWind", windSpeed, 1);
        setNowValue("nowGust", h.windgusts_10m?.[i], 1);
        setWindVane(windDir);
        
        // Обновляем анимацию тайлов
        updateTileAnimation(windSpeed, windDir);
      } else {
        setNowValue("nowAirTemp", null);
        setNowValue("nowWind", null);
        setNowValue("nowGust", null);
        setWindVane(null);
        updateTileAnimation(0, 0);
      }

      // water from Marine hourly (if available)
      const mh = marineJsonOrNull?.hourly;
      if (mh?.time?.length) {
        const j = nearestTimeIndex(mh.time, nowMs);
        setNowValue("nowWater", mh.sea_surface_temperature?.[j], 1);
      } else {
        setNowValue("nowWater", null);
      }
    }

    function setStatus(el, text, kind = "") {
      el.className = "status" + (kind ? " " + kind : "");
      el.textContent = text;
    }

    // ====== АНИМАЦИЯ ТАЙЛОВ ======
    let tileAnimation = {
      canvas: null,
      ctx: null,
      tileImage: null,
      tiles: [],
      windSpeed: 0,      // м/с
      windDirection: 0,  // градусы (0 = север, 90 = восток)
      animFrame: null,
      tileSize: 64,      // размер тайла в пикселях
      density: 0.8,      // плотность тайлов (0-1)
      initialized: false
    };

    function initTileAnimation() {
      const canvas = document.getElementById("tileCanvas");
      if (!canvas) return;
      
      const mapEl = document.getElementById("map");
      if (!mapEl) return;

      tileAnimation.canvas = canvas;
      tileAnimation.ctx = canvas.getContext("2d", { alpha: true });
      
      // Устанавливаем размер canvas равным размеру карты
      function resizeCanvas() {
        const rect = mapEl.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // Загружаем изображение тайла
      const img = new Image();
      img.onload = () => {
        tileAnimation.tileImage = img;
        createTiles();
        if (!tileAnimation.animFrame) {
          animateTiles();
        }
      };
      img.onerror = () => {
        console.warn("Не удалось загрузить tile_1.png");
      };
      img.src = "./tile_1.png";
    }

    function createTiles() {
      if (!tileAnimation.canvas || !tileAnimation.tileImage) return;
      
      const w = tileAnimation.canvas.width;
      const h = tileAnimation.canvas.height;
      const tileSize = tileAnimation.tileSize;
      const density = tileAnimation.density;
      
      // Создаём тайлы с запасом для бесшовного движения
      const cols = Math.ceil(w / tileSize) + 2;
      const rows = Math.ceil(h / tileSize) + 2;
      const totalTiles = Math.floor(cols * rows * density);
      
      tileAnimation.tiles = [];
      for (let i = 0; i < totalTiles; i++) {
        tileAnimation.tiles.push({
          x: (Math.random() * (cols * tileSize)) - tileSize,
          y: (Math.random() * (rows * tileSize)) - tileSize,
          offsetX: Math.random() * tileSize,
          offsetY: Math.random() * tileSize
        });
      }
      
      tileAnimation.initialized = true;
    }

    function updateTileAnimation(windSpeed, windDirection) {
      // Обновляем параметры ветра
      tileAnimation.windSpeed = windSpeed || 0;
      tileAnimation.windDirection = windDirection || 0;
      
      // Если анимация ещё не запущена, запускаем
      if (!tileAnimation.animFrame && tileAnimation.initialized) {
        animateTiles();
      }
    }

    function animateTiles() {
      if (!tileAnimation.canvas || !tileAnimation.ctx || !tileAnimation.tileImage) {
        tileAnimation.animFrame = null;
        return;
      }

      const ctx = tileAnimation.ctx;
      const canvas = tileAnimation.canvas;
      const img = tileAnimation.tileImage;
      const tileSize = tileAnimation.tileSize;
      const w = canvas.width;
      const h = canvas.height;

      // Очищаем canvas
      ctx.clearRect(0, 0, w, h);

      // Вычисляем скорость движения в пикселях за кадр
      // Базовая скорость: 1 м/с = 0.5 пикселей/кадр (можно настроить)
      const baseSpeed = 0.5;
      const speedPx = tileAnimation.windSpeed * baseSpeed;
      
      // Направление ветра в радианах (метеорологическое: 0 = север, по часовой)
      // Для движения на экране: 0° = вверх, 90° = вправо
      const dirRad = ((tileAnimation.windDirection * Math.PI) / 180);
      
      // Вычисляем смещение по X и Y
      // В метеорологии: направление ветра = откуда дует (0° = с севера, т.е. на юг)
      // Для визуализации: направление движения = куда дует (противоположное)
      const moveDirRad = dirRad + Math.PI; // поворачиваем на 180°
      const dx = Math.sin(moveDirRad) * speedPx;
      const dy = -Math.cos(moveDirRad) * speedPx; // минус, т.к. Y растёт вниз

      // Обновляем и рисуем тайлы
      for (const tile of tileAnimation.tiles) {
        // Двигаем тайл
        tile.x += dx;
        tile.y += dy;

        // Обёртка для бесконечного движения
        if (tile.x < -tileSize) tile.x += w + tileSize * 2;
        if (tile.x > w + tileSize) tile.x -= w + tileSize * 2;
        if (tile.y < -tileSize) tile.y += h + tileSize * 2;
        if (tile.y > h + tileSize) tile.y -= h + tileSize * 2;

        // Вычисляем центр тайла для поворота
        const centerX = tile.x + tile.offsetX + tileSize / 2;
        const centerY = tile.y + tile.offsetY + tileSize / 2;

        // Сохраняем состояние контекста
        ctx.save();

        // Перемещаем начало координат в центр тайла
        ctx.translate(centerX, centerY);

        // Поворачиваем на угол направления движения (в направлении ветра)
        ctx.rotate(moveDirRad);

        // Рисуем тайл со смещением на половину размера (чтобы центр совпадал с точкой поворота)
        ctx.drawImage(
          img,
          -tileSize / 2,
          -tileSize / 2,
          tileSize,
          tileSize
        );

        // Восстанавливаем состояние контекста
        ctx.restore();
      }

      tileAnimation.animFrame = requestAnimationFrame(animateTiles);
    }

    // ====== КАРТА ======

    function createPoiElement(label) {
      const el = document.createElement("div");
      el.className = "poiWrap";
      el.innerHTML = `<div class="poiDot"></div><div class="poiLabel"></div>`;
      el.querySelector(".poiLabel").textContent = label;
      return el;
    }

    function addPoi(map, lat, lon, label) {
      const el = createPoiElement(label);
      return new maplibregl.Marker({ element: el, anchor: "left" })
        .setLngLat([lon, lat])
        .addTo(map);
    }

    function initMap() {
      const styleUrl = new URL("./map1.json", window.location.href).toString();
      const mapStatus = document.getElementById("mapStatus");
      setStatus(mapStatus, `Загружаю стиль карты… (${styleUrl})`);

      const map = new maplibregl.Map({
        container: "map",
        style: styleUrl,
        center: [LON, LAT],
        zoom: 12,
        attributionControl: true,
        // disable rotate/tilt gestures
        dragRotate: false,
        pitchWithRotate: false,
        touchZoomRotate: false,
        maxPitch: 0,
        minPitch: 0
      });

      // Extra safety: disable rotation controls if available
      map.dragRotate.disable();
      map.touchZoomRotate.disableRotation();
      map.keyboard.disableRotation();

      map.on("style.load", () => {
        setStatus(mapStatus, "Карта загружена.", "ok");
        // Инициализируем анимацию тайлов после загрузки карты
        setTimeout(() => {
          initTileAnimation();
        }, 100);
      });

      map.on("error", (e) => {
        // MapLibre часто пишет полезный текст в e.error
        const msg = e?.error?.message || e?.error || e?.message || "Не удалось загрузить стиль/тайлы.";
        setStatus(mapStatus, "Ошибка карты: " + msg, "bad");
        // Дополнительно в консоль для отладки
        console.error("MapLibre error:", e);
      });

      map.addControl(new maplibregl.NavigationControl({ showCompass: false }), "top-right");

      new maplibregl.Marker()
        .setLngLat([LON, LAT])
        .setPopup(
          new maplibregl.Popup().setHTML(
            `<b>${PLACE}</b><br/>${LAT.toFixed(3)}, ${LON.toFixed(3)}`
          )
        )
        .addTo(map);

      // POIs из массива
      for (const p of POIS) {
        if (!p) continue;
        addPoi(map, p.lat, p.lon, p.label);
      }
    }

    // ====== ПОГОДА ======
    async function fetchJson(url) {
      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }

    function dailyWaterAveragesFromHourly(marineJson) {
      // Возвращаем Map(date -> avgTemp)
      const map = new Map();
      const hourly = marineJson?.hourly;
      if (!hourly || !hourly.time || !hourly.sea_surface_temperature) return map;

      const times = hourly.time;
      const temps = hourly.sea_surface_temperature;

      const bucket = new Map(); // date -> []
      for (let i = 0; i < times.length; i++) {
        const t = times[i];
        const v = temps[i];
        if (v === null || v === undefined) continue;
        const date = t.slice(0, 10); // YYYY-MM-DD
        if (!bucket.has(date)) bucket.set(date, []);
        bucket.get(date).push(v);
      }

      for (const [date, arr] of bucket.entries()) {
        map.set(date, mean(arr));
      }
      return map;
    }

    function renderForecast(wxJson, waterMap) {
      const tb = document.getElementById("wxTbody");
      const d = wxJson?.daily;
      if (!d) {
        tb.innerHTML = `<tr><td colspan="5" style="color:var(--bad)">Нет данных daily</td></tr>`;
        return;
      }

      const dates = d.time || [];
      const tmax = d.temperature_2m_max || [];
      const tmin = d.temperature_2m_min || [];
      const wmax = d.windspeed_10m_max || [];
      const gmax = d.windgusts_10m_max || [];

      const rows = [];
      for (let i = 0; i < Math.min(6, dates.length); i++) {
        const date = dates[i];
        const water = waterMap?.get(date);
        rows.push(`
          <tr>
            <td class="mono">${fmtDay(date)}</td>
            <td class="mono">${Number(tmin[i]).toFixed(0)} – ${Number(tmax[i]).toFixed(0)}</td>
            <td class="mono">${Number(wmax[i]).toFixed(1)}</td>
            <td class="mono">${Number(gmax[i]).toFixed(1)}</td>
            <td class="mono">${water == null ? "—" : water.toFixed(1)}</td>
          </tr>
        `);
      }
      tb.innerHTML = rows.join("");
    }

    async function loadForecast() {
      const st = document.getElementById("wxStatus");
      setStatus(st, "Загружаю прогноз…");

      try {
        const [wx, marine] = await Promise.allSettled([
          fetchJson(WX_URL),
          fetchJson(MARINE_URL),
        ]);

        if (wx.status !== "fulfilled") throw wx.reason;

        // Рендер «сейчас» (почасовые значения, ближайшие ко времени устройства)
        const marineJsonForNow = marine.status === "fulfilled" ? marine.value : null;
        renderNowStats(wx.value, marineJsonForNow);

        let waterMap = new Map();
        if (marine.status === "fulfilled") {
          waterMap = dailyWaterAveragesFromHourly(marine.value);
          setStatus(st, "Прогноз обновлён. Температура воды: есть данные.", "ok");
        } else {
          setStatus(st, "Прогноз обновлён. Температура воды: источник недоступен — показываю без воды.", "warn");
        }

        renderForecast(wx.value, waterMap);
      } catch (e) {
        renderNowStats({}, null);
        setStatus(st, "Ошибка загрузки прогноза: " + (e?.message || e), "bad");
        document.getElementById("wxTbody").innerHTML =
          `<tr><td colspan="5" style="color:var(--bad)">Не удалось загрузить прогноз</td></tr>`;
      }
    }


    function renderNews(items) {
      const list = document.getElementById("newsList");
      if (!items || items.length === 0) {
        list.innerHTML = `<div style="color:var(--muted)">Ничего не найдено.</div>`;
        return;
      }
      list.innerHTML = items
        .map((n) => `
          <div class="newsItem">
            <div class="t"><a href="${n.link}" target="_blank" rel="noopener noreferrer">${n.title}</a></div>
            <div class="m">${n.source ? n.source + " · " : ""}${n.pubDate}</div>
          </div>
        `)
        .join("");
    }

    async function loadNews() {
      const st = document.getElementById("newsStatus");
      const input = document.getElementById("rssQuery");

      setStatus(st, "Загружаю новости из кеша…");

      try {
        const r = await fetch("./news_cache.json", { cache: "no-store" });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const json = await r.json();

        // Подставим реальный запрос из кеша (если отличается от того, что в поле)
        if (json?.query && input) input.value = json.query;

        const items = Array.isArray(json?.items) ? json.items : [];
        setStatus(
          st,
          `Кеш обновлён: ${new Date(json.updatedAt).toLocaleString("ru-RU")}. Показано ${items.length} новостей.`,
          "ok"
        );
        renderNews(items);
      } catch (e) {
        setStatus(st, "Не удалось загрузить кеш новостей: " + (e?.message || e), "bad");
        document.getElementById("newsList").innerHTML = "";
      }
    }

    // ====== ИНИТ ======
    window.addEventListener("DOMContentLoaded", () => {
      initMap();

      document.getElementById("btnRefresh").addEventListener("click", loadForecast);
      const btnNews = document.getElementById("btnNews");
      btnNews.addEventListener("click", loadNews);

      // Автозагрузка
      loadForecast();
      loadNews(); // новости запрашиваем сразу при старте

      // Кнопку "Обновить новости" показываем только через 5 минут
      setTimeout(() => {
        btnNews.style.display = "inline-flex";
      }, 5 * 60 * 1000);
    });
  </script>
</body>
</html>
