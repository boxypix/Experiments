<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Анапа — прогноз + новости о мазуте</title>

  <link
    href="https://unpkg.com/maplibre-gl@4.0.2/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <script
    src="https://unpkg.com/maplibre-gl@4.0.2/dist/maplibre-gl.js"
    defer
  ></script>

  <style>
    :root{
      --bg:#0f1320;
      --card:#151a27;
      --text:#d7dcec;
      --muted:#9aa3bd;
      --line:#232a41;
      --accent:#6aa6ff;
      --ok:#62d26f;
      --warn:#ffb020;
      --bad:#ff5a6a;
      --radius:14px;
      --pad:16px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{
      margin:0;
      padding:0;
      width:100%;
      overflow-x:hidden;
    }
    html{
      scroll-behavior:smooth;
    }
    body{
      font-family:var(--font);
      background:linear-gradient(180deg, #0b1020 0%, var(--bg) 100%);
      color:var(--text);
      min-width:0;
    }
    header{
      padding:22px var(--pad) 8px;
      max-width:1100px;
      margin:0 auto;
      width:100%;
    }
    h1{margin:0 0 6px; font-size:34px; font-weight:700}
    .sub{color:var(--muted); font-size:13px}
    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding:12px var(--pad) 40px;
      width:100%;
      min-width:0;
    }
    .grid{
      display:grid;
      gap:14px;
      width:100%;
      min-width:0;
    }
    .card{
      width:100%;
      min-width:0;
      margin-bottom:36px;
    }
    .hourlyForecastCard{
      overflow:visible;
    }
    #map{height:340px; border-radius:12px; overflow:hidden; position:relative}
    .poiDot{width:8px; height:8px; border-radius:999px; background:#ff3b30; box-shadow:0 0 0 2px rgba(0,0,0,.35)}
    .poiLabel{
      margin-left:8px;
      font-size:14px;
      font-weight:600;
      color:#ffffff;
      /* обводка: чёрная с прозрачностью 0.5 */
      -webkit-text-stroke: 1px rgba(15, 15, 15, 0.5);
      /* fallback, если stroke не поддерживается */
      text-shadow:
        1px 0 rgba(0,0,0,.5),
        -1px 0 rgba(0,0,0,.5),
        0 1px rgba(0,0,0,.5),
        0 -1px rgba(0,0,0,.5);
    }
    .poiWrap{display:flex; align-items:center}
    .vaneBox{
      position:absolute;
      top:10px;
      left:10px;
      z-index:2;
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-radius:12px;
      border:none;
      background:rgba(0,0,0,0.9);
      backdrop-filter: blur(6px);
    }
    .vaneArrowWrap{
      width:36px;
      height:36px;
      display:grid;
      place-items:center;
    }
    .vaneArrow{
      width:32px;
      height:32px;
      max-width:100%;
      display:block;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,.6));
      transform-origin: 50% 50%;
      transform: rotate(0deg);
      user-select:none;
      pointer-events:none;
    }
    img{
      max-width:100%;
      height:auto;
    }
    .vaneText{display:flex; flex-direction:column; line-height:1.1}
    .vaneLabel{font-size:12px; font-weight:400; color:var(--muted)}
    .vaneValue{font-size:20px; font-weight:800; color:var(--text)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      border:1px solid var(--line);
      padding:8px 10px;
      border-radius:999px;
      background:rgba(0,0,0,.15);
      color:var(--muted);
      font-size:12px;
    }
    .pill b{color:var(--text); font-weight:700}
    .controls{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px
    }
    input[type="text"]{
      width:min(680px,100%);
      padding:10px 12px;
      border-radius:10px;
      border:1px solid var(--line);
      outline:none;
      background:rgba(0,0,0,.22);
      color:var(--text);
    }
    button{
      padding:10px 12px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(106,166,255,.12);
      color:var(--text);
      cursor:pointer;
      font-weight:700;
    }
    button:hover{border-color:rgba(106,166,255,.5)}
    .hint{color:var(--muted); font-size:12px; margin-top:8px; line-height:1.45}
    .status{margin-top:10px; color:var(--muted); font-size:12px}
    .status.ok{color:var(--ok)}
    .status.warn{color:var(--warn)}
    .status.bad{color:var(--bad)}

    table{
      width:100%;
      max-width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.12);
    }
    thead th{
      text-align:left;
      font-size:12px;
      color:var(--muted);
      padding:10px 12px;
      background:#11172a;
      border-bottom:1px solid var(--line);
      font-weight:700;
    }
    #hourlyTable thead th strong{
      font-weight:700;
    }
    tbody td{
      padding:10px 12px;
      border-bottom:1px solid rgba(35,42,65,.65);
      font-size:13px;
    }
    tbody tr:last-child td{border-bottom:none}
    .mono{font-variant-numeric:tabular-nums}

    /* Фиксированный первый столбец для почасовой таблицы */
    .hourlyTableWrapper{
      width:100%;
      overflow-x:auto;
      overflow-y:visible;
    }
    #hourlyTable{
      width:auto;
      min-width:100%;
      table-layout:auto;
    }
    #hourlyTable thead th:first-child,
    #hourlyTable tbody td:first-child{
      position:sticky;
      left:0;
      z-index:10;
      background:rgba(0,0,0,.12);
      border-right:1px solid var(--line);
      box-shadow:2px 0 4px rgba(0,0,0,.15);
      width:90px;
      min-width:90px;
      padding:16px 8px;
      min-height:60px;
      display:flex;
      align-items:center;
      gap:4px;
    }
    #hourlyTable thead th:first-child{
      background:#11172a;
      z-index:11;
    }
    #hourlyTable tbody tr td:first-child{
      background:rgba(0,0,0,.12);
    }
    #hourlyTable tbody tr:last-child td:first-child{
      border-bottom:none;
    }
    /* Стиль для текста в первом столбце с названиями строк (кроме первой строки с временем) */
    #hourlyTable tbody tr:not(:first-child) td:first-child{
      font-size:7pt;
      color:#f7f9fb;
    }
    #hourlyTable tbody tr:not(:first-child) td:first-child > span{
      flex:1;
      line-height:1.3;
    }
    .rowIcon{
      width:20px;
      height:20px;
      flex-shrink:0;
      display:block;
      margin-top:2px;
    }
    /* Остальные столбцы растягиваются и скроллятся */
    #hourlyTable thead th:not(:first-child),
    #hourlyTable tbody td:not(:first-child){
      min-width:65px;
      white-space:nowrap;
      padding:16px 8px;
      position:relative;
      min-height:60px;
    }
    #hourlyTable tbody tr{
      height:60px;
    }
    #hourlyTable tbody td:not(:first-child){
      vertical-align:bottom;
    }
    .hourlyBar{
      position:absolute;
      bottom:0;
      left:0;
      right:0;
      /* Градиент: вертикальный от белого к прозрачному белому (снизу вверх)
         Чтобы изменить цвет градиента, замените rgba(255,255,255,...) на нужный цвет
         Например: rgba(255,100,100,0.3) для красного, rgba(100,255,100,0.3) для зеленого */
      background:linear-gradient(to top, rgba(48, 71, 104, 0.605), rgba(77, 105, 156, 0));
      border-radius:2px 2px 0 0;
      pointer-events:none;
      z-index:0;
      transition:height 0.3s ease;
      min-height:7px;
    }
    #hourlyTable tbody td:not(:first-child) .cellContent{
      position:relative;
      z-index:1;
    }
    /* Пульсация для столбца "Сейчас" */
    @keyframes pulseNow {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    #hourlyTable thead th:nth-child(2),
    #hourlyTable thead th:nth-child(2) strong,
    #hourlyTable tbody td:nth-child(2),
    #hourlyTable tbody td:nth-child(2) .cellContent{
      animation: pulseNow 2s ease-in-out infinite;
      color: #ffffff !important;
    }

    .loadingText{
      font-size:24px;
      font-weight:700;
      animation:loadingPulse 1s ease-in-out infinite;
    }
    @keyframes loadingPulse{
      0%{opacity:1}
      50%{opacity:.5}
      100%{opacity:1}
    }

    .statsRow{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:10px;
      align-items:stretch;
      margin-top:12px;
      width:100%;
      min-width:0;
    }
    @media (min-width: 860px){
      .statsRow{ grid-template-columns: repeat(4, minmax(0, 1fr)); }
    }
    .statCard{
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(0,0,0,.14);
      padding:10px 12px;
      width:100%;
      min-width:0;
      overflow:hidden;
    }
    .statLabel{font-size:12px; font-weight:400; color:var(--muted); line-height:1.2}
    .statValue{
      margin-top:6px;
      font-size:32px;
      font-weight:800;
      line-height:1;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .statIcon{
      width:24px;
      height:24px;
      flex-shrink:0;
      display:block;
      opacity: 1;
    }
    .statUnit{font-size:14px; font-weight:700; color:var(--muted); margin-left:6px}
    .lastNewsBadge{
      display:inline-block;
      padding:6px 12px;
      border-radius:8px;
      background:#FF7E38;
      color:#000000;
      font-weight:400;
      font-size:13px;
      margin-top:8px;
      margin-bottom:12px;
    }
    .news{
      display:grid;
      gap:10px;
      margin-top:10px;
    }
    .news a{
      color:var(--text);
      text-decoration:none;
    }
    .news a:hover{color:var(--accent)}
    .newsItem{
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(0,0,0,.14);
    }
    .newsItem .t{font-weight:700; line-height:1.35}
    .newsItem .m{margin-top:6px; color:var(--muted); font-size:12px}
    footer{
      max-width:1100px;
      margin:0 auto;
      padding:0 var(--pad) 22px;
      color:var(--muted);
      font-size:12px;
      width:100%;
      min-width:0;
    }

    /* Нижний стек с навигацией */
    .bottomNav{
      position:fixed;
      bottom:0;
      left:0;
      right:0;
      width:100%;
      background:#000000;
      border-radius:20px 20px 0 0;
      display:flex;
      align-items:center;
      padding:12px 0;
      z-index:1000;
      box-shadow:0 -2px 10px rgba(0,0,0,.3);
    }
    .navBtn{
      flex:1;
      background:transparent;
      border:none;
      color:#ffffff;
      font-size:14px;
      font-weight:500;
      padding:10px 0;
      cursor:pointer;
      text-align:center;
      text-decoration:none;
      display:block;
    }
    .navBtn:hover{
      opacity:0.8;
    }
    .navBtn:visited,
    .navBtn:active,
    .navBtn:focus{
      text-decoration:none;
      color:#ffffff;
    }
    .navDivider{
      width:1px;
      height:20px;
      background:rgba(255, 255, 255, 0.06);
      flex-shrink:0;
    }
    /* Отступ снизу для контента, чтобы не перекрывался навигацией */
    body{
      padding-bottom:60px;
    }

    /* Мобильная адаптивность */
    @media (max-width: 480px){
      :root{
        --pad:12px;
      }
      h1{font-size:28px}
      .card{padding:0px}
      #map{height:280px}
      .statValue{font-size:28px}
      .vaneBox{
        padding:6px 8px;
        font-size:12px;
      }
    }
  </style>
</head>

<body>
  <header>
    <h1>Анапа — обстановка</h1>
    <div class="sub">Карта сверху, прогноз на 6 дней, новости RSS по мазуту.</div>
  </header>

  <div class="wrap grid">
    <!-- MAP -->
    <section id="now" class="card">
      <div class="row">
      </div>
      <div class="statsRow" aria-label="Погода сейчас">
        <div class="statCard">
          <div class="statLabel">Ветер</div>
          <div class="statValue">
            <img src="./i_wind.png" alt="" class="statIcon" />
            <span id="nowWind" class="mono">—</span><span class="statUnit">м/с</span>
          </div>
        </div>
        <div class="statCard">
          <div class="statLabel">Порывы</div>
          <div class="statValue">
            <img src="./i_wind.png" alt="" class="statIcon" />
            <span id="nowGust" class="mono">—</span><span class="statUnit">м/с</span>
          </div>
        </div>
        <div class="statCard">
          <div class="statLabel">Воздух</div>
          <div class="statValue">
            <img src="./i_temp.png" alt="" class="statIcon" />
            <span id="nowAirTemp" class="mono">—</span><span class="statUnit">°C</span>
          </div>
        </div>
        <div class="statCard">
          <div class="statLabel">Температура воды</div>
          <div class="statValue">
            <img src="./i_water.png" alt="" class="statIcon" />
            <span id="nowWater" class="mono">—</span><span class="statUnit">°C</span>
          </div>
        </div>
      </div>
      <div id="map" style="margin-top:12px">
        <div class="vaneBox" id="windVane" aria-label="Флюгер ветра">
          <div class="vaneArrowWrap"><img class="vaneArrow" id="windVaneArrow" src="./arrow.svg" alt="" /></div>
          <div class="vaneText">
            <div class="vaneLabel">Ветер</div>
            <div class="vaneValue"><span id="windVaneDeg" class="mono">—</span>° <span id="windVaneDir">—</span></div>
          </div>
        </div>
      </div>
      <div class="status" id="mapStatus" style="margin-top:10px">—</div>
      <!-- <div class="hint">
        Карта — MapLibre GL JS. Стиль берётся из локального файла <span class="mono">map1.json</span> (рядом с <span class="mono">spot.html</span>).
      </div> -->
    </section>

    <!-- HOURLY FORECAST -->
    <section id="hourly" class="card hourlyForecastCard">
      <div style="font-weight:800; font-size:24px">Почасовой прогноз <br>6 часов</div>
      <div class="hint">Температура воздуха, скорость ветра, порывы и температура воды.</div>
      
      <div class="hourlyTableWrapper" style="margin-top:10px">
        <table id="hourlyTable">
          <thead id="hourlyThead">
            <tr>
              <th></th>
              <th>Сейчас</th>
              <th>+3 ч</th>
              <th>+6 ч</th>
              <th>+9 ч</th>
              <th>+12 ч</th>
              <th>+15 ч</th>
              <th>+18 ч</th>
            </tr>
          </thead>
          <tbody id="hourlyTbody">
            <tr><td colspan="8" class="mono loadingText" style="color:var(--muted)">Загрузка…</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- FORECAST -->
    <section id="forecast" class="card">
      <div class="row" style="justify-content:space-between">
        <div>
          <div style="font-weight:800; font-size:24px">Прогноз на сегодня <br>+ 5 дней</div>
          <div class="hint">Ветер, порывы, температура воздуха и (если доступно) температура воды.</div>
        </div>
        <button id="btnRefresh">Обновить</button>
      </div>

      <div class="status" id="wxStatus">—</div>

      <div style="margin-top:10px; overflow-x:auto; width:100%; min-width:0">
        <table style="width:100%; min-width:0">
          <thead>
            <tr>
              <th>День</th>
              <th>Ветер м/с (max)</th>
              <th>Порывы м/с (max)</th>
              <th>Воздух °C (min–max)</th>
              <th>Вода °C (ср.)</th>
            </tr>
          </thead>
          <tbody id="wxTbody">
            <tr><td colspan="5" class="mono loadingText" style="color:var(--muted)">Загрузка…</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- RSS -->
    <section id="news" class="card">
      <div style="font-weight:800; font-size:24px">Новости о мазуте (RSS)</div>
      <div class="lastNewsBadge" id="lastNewsBadge" style="display:none">Последняя новость была <span id="lastNewsDate">—</span></div>
      <div class="controls">
        <input id="rssQuery" type="text" value="мазут Анапа Краснодар" readonly />
        <button id="btnNews" style="display:none">Обновить новости</button>
      </div>
      <div class="hint">
        Новости обновляются каждые 24 часа на основе открытых RSS источников из интернета.
      </div>

      <div class="status" id="newsStatus">—</div>
      <div class="news" id="newsList"></div>
    </section>
  </div>

  <!-- Нижний стек с навигацией -->
  <nav class="bottomNav">
    <a href="#now" class="navBtn">Сейчас</a>
    <div class="navDivider"></div>
    <a href="#hourly" class="navBtn">На день</a>
    <div class="navDivider"></div>
    <a href="#forecast" class="navBtn">На неделю</a>
    <div class="navDivider"></div>
    <a href="#news" class="navBtn">Мазут</a>
  </nav>

  <!-- <footer>
    Подсказка: чтобы уменьшить нагрузку на источники, можно добавить кеширование (например, через Cloudflare Worker).
  </footer> -->

  <script>
    // ====== НАСТРОЙКИ (Анапа) ======
    const PLACE = "Анапа";
    const LAT = 44.894;     // примерно центр Анапы
    const LON = 37.316;

    // POI точки (добавляй новые элементы сюда)
    // lat / lon — координаты, label — подпись
    const POIS = [
      // { lat: 44.8917273, lon: 37.2963998, label: "Пляж" },
    ];

    // Open-Meteo (погода) — daily на 6 дней
    const WX_URL =
      "https://api.open-meteo.com/v1/forecast" +
      `?latitude=${LAT}&longitude=${LON}` +
      "&timezone=Europe/Moscow" +
      "&forecast_days=6" +
      "&daily=temperature_2m_max,temperature_2m_min,windspeed_10m_max,windgusts_10m_max" +
      "&hourly=temperature_2m,windspeed_10m,windgusts_10m,winddirection_10m";

    // Open-Meteo (море) — sea surface temperature hourly, потом сведём в среднее по дням
    // Если у Open-Meteo Marine что-то поменяется, просто отключится вода (код это переживёт).
    const MARINE_URL =
      "https://marine-api.open-meteo.com/v1/marine" +
      `?latitude=${LAT}&longitude=${LON}` +
      "&timezone=Europe/Moscow" +
      "&forecast_days=6" +
      "&hourly=sea_surface_temperature";


    // ====== УТИЛИТЫ ======
    const fmtDay = (isoDate) => {
      // isoDate: YYYY-MM-DD
      const d = new Date(isoDate + "T00:00:00");
      return d.toLocaleDateString("ru-RU", { weekday: "short", day: "2-digit", month: "2-digit" });
    };

    const mean = (arr) => {
      if (!arr || arr.length === 0) return null;
      let s = 0;
      for (const x of arr) s += x;
      return s / arr.length;
    };

    function nearestTimeIndex(times, nowMs) {
      // times: array of ISO strings (e.g., 2026-01-08T12:00)
      if (!times || times.length === 0) return -1;
      let bestI = 0;
      let bestD = Infinity;
      for (let i = 0; i < times.length; i++) {
        const ms = Date.parse(times[i]);
        if (!Number.isFinite(ms)) continue;
        const d = Math.abs(ms - nowMs);
        if (d < bestD) {
          bestD = d;
          bestI = i;
        }
      }
      return bestI;
    }

    function setNowValue(id, v, digits = 0) {
      const el = document.getElementById(id);
      if (!el) return;
      if (v === null || v === undefined || Number.isNaN(v)) {
        el.textContent = "—";
        return;
      }
      el.textContent = Number(v).toFixed(digits);
    }

    function getWindDirection(deg) {
      // Преобразует градусы в текстовое направление ветра
      const directions = [
        { min: 337.5, max: 22.5, dir: 'С' },
        { min: 22.5, max: 67.5, dir: 'СВ' },
        { min: 67.5, max: 112.5, dir: 'В' },
        { min: 112.5, max: 157.5, dir: 'ЮВ' },
        { min: 157.5, max: 202.5, dir: 'Ю' },
        { min: 202.5, max: 247.5, dir: 'ЮЗ' },
        { min: 247.5, max: 292.5, dir: 'З' },
        { min: 292.5, max: 337.5, dir: 'СЗ' }
      ];
      
      const normalizedDeg = ((deg % 360) + 360) % 360;
      
      for (const dir of directions) {
        if (dir.min > dir.max) {
          // Для С (север) - особый случай, так как диапазон переходит через 0
          if (normalizedDeg >= dir.min || normalizedDeg < dir.max) {
            return dir.dir;
          }
        } else {
          if (normalizedDeg >= dir.min && normalizedDeg < dir.max) {
            return dir.dir;
          }
        }
      }
      return '—';
    }

    function setWindVane(deg) {
      const degEl = document.getElementById("windVaneDeg");
      const dirEl = document.getElementById("windVaneDir");
      const arrowEl = document.getElementById("windVaneArrow");
      if (!degEl || !arrowEl) return;

      if (deg === null || deg === undefined || Number.isNaN(deg)) {
        degEl.textContent = "—";
        if (dirEl) dirEl.textContent = "—";
        arrowEl.style.opacity = "0.35";
        arrowEl.style.transform = "rotate(0deg)";
        return;
      }

      const d = ((Number(deg) % 360) + 360) % 360;
      degEl.textContent = d.toFixed(0);
      if (dirEl) dirEl.textContent = getWindDirection(d);
      arrowEl.style.opacity = "1";
      // Поворачиваем стрелку на градусы направления ветра (как в данных источника)
      arrowEl.style.transform = `rotate(${d}deg)`;
    }

    function renderNowStats(wxJson, marineJsonOrNull) {
      const nowMs = Date.now();

      // air + wind + gust from Open-Meteo hourly
      const h = wxJson?.hourly;
      if (h?.time?.length) {
        const i = nearestTimeIndex(h.time, nowMs);
        setNowValue("nowAirTemp", h.temperature_2m?.[i], 0);
        setNowValue("nowWind", h.windspeed_10m?.[i], 1);
        setNowValue("nowGust", h.windgusts_10m?.[i], 1);
        setWindVane(h.winddirection_10m?.[i]);
      } else {
        setNowValue("nowAirTemp", null);
        setNowValue("nowWind", null);
        setNowValue("nowGust", null);
        setWindVane(null);
      }

      // water from Marine hourly (if available)
      const mh = marineJsonOrNull?.hourly;
      if (mh?.time?.length) {
        const j = nearestTimeIndex(mh.time, nowMs);
        setNowValue("nowWater", mh.sea_surface_temperature?.[j], 1);
      } else {
        setNowValue("nowWater", null);
      }
    }

    function setStatus(el, text, kind = "") {
      el.className = "status" + (kind ? " " + kind : "");
      el.textContent = text;
    }

    // ====== КАРТА ======

    function createPoiElement(label) {
      const el = document.createElement("div");
      el.className = "poiWrap";
      el.innerHTML = `<div class="poiDot"></div><div class="poiLabel"></div>`;
      el.querySelector(".poiLabel").textContent = label;
      return el;
    }

    function addPoi(map, lat, lon, label) {
      const el = createPoiElement(label);
      return new maplibregl.Marker({ element: el, anchor: "left" })
        .setLngLat([lon, lat])
        .addTo(map);
    }

    function initMap() {
      const styleUrl = new URL("./map1.json", window.location.href).toString();
      const mapStatus = document.getElementById("mapStatus");
      setStatus(mapStatus, `Загружаю стиль карты… (${styleUrl})`);

      const map = new maplibregl.Map({
        container: "map",
        style: styleUrl,
        center: [LON, LAT],
        zoom: 12,
        attributionControl: true,
        // disable rotate/tilt gestures
        dragRotate: false,
        pitchWithRotate: false,
        touchZoomRotate: false,
        maxPitch: 0,
        minPitch: 0
      });

      // Extra safety: disable rotation controls if available
      map.dragRotate.disable();
      map.touchZoomRotate.disableRotation();
      map.keyboard.disableRotation();

      map.on("style.load", () => {
        setStatus(mapStatus, "Карта загружена.", "ok");
      });

      map.on("error", (e) => {
        // MapLibre часто пишет полезный текст в e.error
        const msg = e?.error?.message || e?.error || e?.message || "Не удалось загрузить стиль/тайлы.";
        setStatus(mapStatus, "Ошибка карты: " + msg, "bad");
        // Дополнительно в консоль для отладки
        console.error("MapLibre error:", e);
      });

      map.addControl(new maplibregl.NavigationControl({ showCompass: false }), "top-right");

      new maplibregl.Marker()
        .setLngLat([LON, LAT])
        .setPopup(
          new maplibregl.Popup().setHTML(
            `<b>${PLACE}</b><br/>${LAT.toFixed(3)}, ${LON.toFixed(3)}`
          )
        )
        .addTo(map);

      // POIs из массива
      for (const p of POIS) {
        if (!p) continue;
        addPoi(map, p.lat, p.lon, p.label);
      }
    }

    // ====== ПОГОДА ======
    async function fetchJson(url) {
      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }

    function dailyWaterAveragesFromHourly(marineJson) {
      // Возвращаем Map(date -> avgTemp)
      const map = new Map();
      const hourly = marineJson?.hourly;
      if (!hourly || !hourly.time || !hourly.sea_surface_temperature) return map;

      const times = hourly.time;
      const temps = hourly.sea_surface_temperature;

      const bucket = new Map(); // date -> []
      for (let i = 0; i < times.length; i++) {
        const t = times[i];
        const v = temps[i];
        if (v === null || v === undefined) continue;
        const date = t.slice(0, 10); // YYYY-MM-DD
        if (!bucket.has(date)) bucket.set(date, []);
        bucket.get(date).push(v);
      }

      for (const [date, arr] of bucket.entries()) {
        map.set(date, mean(arr));
      }
      return map;
    }

    function renderForecast(wxJson, waterMap) {
      const tb = document.getElementById("wxTbody");
      const d = wxJson?.daily;
      if (!d) {
        tb.innerHTML = `<tr><td colspan="5" style="color:var(--bad)">Нет данных daily</td></tr>`;
        return;
      }

      const dates = d.time || [];
      const tmax = d.temperature_2m_max || [];
      const tmin = d.temperature_2m_min || [];
      const wmax = d.windspeed_10m_max || [];
      const gmax = d.windgusts_10m_max || [];

      const rows = [];
      for (let i = 0; i < Math.min(6, dates.length); i++) {
        const date = dates[i];
        const water = waterMap?.get(date);
        rows.push(`
          <tr>
            <td class="mono">${fmtDay(date)}</td>
            <td class="mono">${Number(wmax[i]).toFixed(1)}</td>
            <td class="mono">${Number(gmax[i]).toFixed(1)}</td>
            <td class="mono">${Number(tmin[i]).toFixed(0)} – ${Number(tmax[i]).toFixed(0)}</td>
            <td class="mono">${water == null ? "—" : water.toFixed(1)}</td>
          </tr>
        `);
      }
      tb.innerHTML = rows.join("");
    }

    function getBarHeight(value, min, max) {
      if (value == null || isNaN(value)) return 0;
      if (min === max) return 50; // Если все значения одинаковые, показываем 50%
      // Минимальная высота 7px (при высоте строки 60px это ~11.67%)
      // Максимальная высота: 60px - 9px = 51px (85% от высоты строки)
      const minHeightPercent = 11.67;
      const maxHeightPercent = 85; // Оставляем 9px сверху
      const calculatedHeight = ((value - min) / (max - min)) * 100;
      return Math.max(minHeightPercent, Math.min(calculatedHeight, maxHeightPercent));
    }

    function renderHourlyForecast(wxJson, marineJsonOrNull) {
      const tb = document.getElementById("hourlyTbody");
      const nowMs = Date.now();
      
      const h = wxJson?.hourly;
      if (!h || !h.time || h.time.length === 0) {
        tb.innerHTML = `<tr><td colspan="8" style="color:var(--bad)">Нет почасовых данных</td></tr>`;
        return;
      }

      // Находим индекс текущего времени
      const currentIdx = nearestTimeIndex(h.time, nowMs);
      if (currentIdx < 0 || currentIdx >= h.time.length) {
        tb.innerHTML = `<tr><td colspan="8" style="color:var(--bad)">Не удалось найти текущее время</td></tr>`;
        return;
      }

      // Получаем данные для "сейчас" и далее каждые 3 часа
      const times = h.time;
      const airTemps = h.temperature_2m || [];
      const windSpeeds = h.windspeed_10m || [];
      const gusts = h.windgusts_10m || [];
      
      const marineHourly = marineJsonOrNull?.hourly;
      const waterTemps = marineHourly?.sea_surface_temperature || [];

      // Собираем все значения для каждой строки
      const airValues = [];
      const windValues = [];
      const gustValues = [];
      const waterValues = [];

      // Собираем данные: "сейчас" и далее каждые 3 часа
      const timeCells = ['<td class="mono">Время</td>'];
      const airDisplays = [];
      const windDisplays = [];
      const gustDisplays = [];
      const waterDisplays = [];
      const headerHours = []; // Для заголовков

      // Первый столбец - "сейчас"
      const nowDate = new Date(times[currentIdx]);
      const nowHour = nowDate.getHours();
      const nowTimeStr = `${String(nowHour).padStart(2, '0')}:00`;
      headerHours.push(nowTimeStr);
      timeCells.push(`<td class="mono">${nowTimeStr}</td>`);
      
      const airTempNow = airTemps[currentIdx];
      airValues.push(airTempNow);
      airDisplays.push(airTempNow != null ? Number(airTempNow).toFixed(0) : '—');
      
      const windNow = windSpeeds[currentIdx];
      windValues.push(windNow);
      windDisplays.push(windNow != null ? Number(windNow).toFixed(1) : '—');
      
      const gustNow = gusts[currentIdx];
      gustValues.push(gustNow);
      gustDisplays.push(gustNow != null ? Number(gustNow).toFixed(1) : '—');
      
      const waterNow = waterTemps[currentIdx];
      waterValues.push(waterNow);
      waterDisplays.push(waterNow != null ? Number(waterNow).toFixed(1) : '—');

      // Далее каждые 3 часа (максимум 6 столбцов после "сейчас")
      for (let i = 1; i <= 6; i++) {
        const offset = i * 3; // Каждые 3 часа
        const idx = currentIdx + offset;
        if (idx >= times.length) break;

        const timeStr = times[idx];
        const date = new Date(timeStr);
        const hour = date.getHours();
        const timeStrFormatted = `${String(hour).padStart(2, '0')}:00`;
        headerHours.push(timeStrFormatted);
        timeCells.push(`<td class="mono">${timeStrFormatted}</td>`);
        
        const airTemp = airTemps[idx];
        airValues.push(airTemp);
        airDisplays.push(airTemp != null ? Number(airTemp).toFixed(0) : '—');
        
        const wind = windSpeeds[idx];
        windValues.push(wind);
        windDisplays.push(wind != null ? Number(wind).toFixed(1) : '—');
        
        const gust = gusts[idx];
        gustValues.push(gust);
        gustDisplays.push(gust != null ? Number(gust).toFixed(1) : '—');
        
        const water = waterTemps[idx];
        waterValues.push(water);
        waterDisplays.push(water != null ? Number(water).toFixed(1) : '—');
      }

      // Если не хватает данных, заполняем пустыми ячейками
      while (timeCells.length < 8) {
        timeCells.push('<td class="mono">—</td>');
        headerHours.push(null);
        airValues.push(null);
        windValues.push(null);
        gustValues.push(null);
        waterValues.push(null);
        airDisplays.push('—');
        windDisplays.push('—');
        gustDisplays.push('—');
        waterDisplays.push('—');
      }

      // Вычисляем min и max для каждой строки
      const airValid = airValues.filter(v => v != null && !isNaN(v));
      const windValid = windValues.filter(v => v != null && !isNaN(v));
      const gustValid = gustValues.filter(v => v != null && !isNaN(v));
      const waterValid = waterValues.filter(v => v != null && !isNaN(v));

      const airMin = airValid.length > 0 ? Math.min(...airValid) : 0;
      const airMax = airValid.length > 0 ? Math.max(...airValid) : 1;
      const windMin = windValid.length > 0 ? Math.min(...windValid) : 0;
      const windMax = windValid.length > 0 ? Math.max(...windValid) : 1;
      const gustMin = gustValid.length > 0 ? Math.min(...gustValid) : 0;
      const gustMax = gustValid.length > 0 ? Math.max(...gustValid) : 1;
      const waterMin = waterValid.length > 0 ? Math.min(...waterValid) : 0;
      const waterMax = waterValid.length > 0 ? Math.max(...waterValid) : 1;

      // Функция для создания строки с диаграммами
      const createRow = (label, values, displays, min, max, showBar = true) => {
        const cells = [label];
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          const height = showBar ? getBarHeight(value, min, max) : 0;
          const bar = (showBar && height > 0) ? `<div class="hourlyBar" style="height:${height}%"></div>` : '';
          cells.push(`<td class="mono"><div class="cellContent">${displays[i]}</div>${bar}</td>`);
        }
        return cells.join('');
      };

      // Обновляем заголовки таблицы с временем
      const thead = document.getElementById("hourlyThead");
      if (thead) {
        const headerCells = thead.querySelectorAll('th:not(:first-child)');
        headerCells.forEach((th, i) => {
          if (i === 0) {
            th.innerHTML = '<strong>Сейчас</strong>';
          } else if (headerHours[i] != null) {
            th.innerHTML = `<strong>${headerHours[i]}</strong>`;
          } else {
            th.innerHTML = `<strong>+${i * 3} ч</strong>`;
          }
        });
      }

      tb.innerHTML = `
        <tr>${timeCells.join('')}</tr>
        <tr>${createRow('<td><img src="./i_wind.png" alt="" class="rowIcon" /><span>Ветер<br>м/с</span></td>', windValues, windDisplays, windMin, windMax, true)}</tr>
        <tr>${createRow('<td><img src="./i_wind.png" alt="" class="rowIcon" /><span>Порывы,<br>м/с</span></td>', gustValues, gustDisplays, gustMin, gustMax, true)}</tr>
        <tr>${createRow('<td><img src="./i_temp.png" alt="" class="rowIcon" /><span>Воздух<br>°C</span></td>', airValues, airDisplays, airMin, airMax, true)}</tr>
        <tr>${createRow('<td><img src="./i_water.png" alt="" class="rowIcon" /><span>Вода<br>°C</span></td>', waterValues, waterDisplays, waterMin, waterMax, false)}</tr>
      `;
    }

    async function loadForecast() {
      const st = document.getElementById("wxStatus");
      setStatus(st, "Загружаю прогноз…");

      try {
        const [wx, marine] = await Promise.allSettled([
          fetchJson(WX_URL),
          fetchJson(MARINE_URL),
        ]);

        if (wx.status !== "fulfilled") throw wx.reason;

        // Рендер «сейчас» (почасовые значения, ближайшие ко времени устройства)
        const marineJsonForNow = marine.status === "fulfilled" ? marine.value : null;
        renderNowStats(wx.value, marineJsonForNow);

        let waterMap = new Map();
        if (marine.status === "fulfilled") {
          waterMap = dailyWaterAveragesFromHourly(marine.value);
          setStatus(st, "Прогноз обновлён. Температура воды: есть данные.", "ok");
        } else {
          setStatus(st, "Прогноз обновлён. Температура воды: источник недоступен — показываю без воды.", "warn");
        }

        renderForecast(wx.value, waterMap);
        renderHourlyForecast(wx.value, marineJsonForNow);
      } catch (e) {
        renderNowStats({}, null);
        renderHourlyForecast({}, null);
        setStatus(st, "Ошибка загрузки прогноза: " + (e?.message || e), "bad");
        document.getElementById("wxTbody").innerHTML =
          `<tr><td colspan="5" style="color:var(--bad)">Не удалось загрузить прогноз</td></tr>`;
      }
    }


    function formatDate(dateStr) {
      // Форматирует дату в формат "12 янв 2025"
      try {
        const date = new Date(dateStr);
        const day = date.getDate();
        const months = ['янв', 'фев', 'мар', 'апр', 'май', 'июн', 'июл', 'авг', 'сен', 'окт', 'ноя', 'дек'];
        const month = months[date.getMonth()];
        const year = date.getFullYear();
        return `${day} ${month} ${year}`;
      } catch (e) {
        return dateStr;
      }
    }

    function renderNews(items) {
      const list = document.getElementById("newsList");
      const badge = document.getElementById("lastNewsBadge");
      const badgeDate = document.getElementById("lastNewsDate");
      
      if (!items || items.length === 0) {
        list.innerHTML = `<div style="color:var(--muted)">Ничего не найдено.</div>`;
        if (badge) badge.style.display = 'none';
        return;
      }

      // Находим последнюю новость по дате публикации
      const sortedItems = [...items].sort((a, b) => {
        const dateA = new Date(a.pubDate || 0);
        const dateB = new Date(b.pubDate || 0);
        return dateB - dateA;
      });

      const lastNews = sortedItems[0];
      if (lastNews && lastNews.pubDate && badge && badgeDate) {
        badgeDate.textContent = formatDate(lastNews.pubDate);
        badge.style.display = 'inline-block';
      } else if (badge) {
        badge.style.display = 'none';
      }

      list.innerHTML = items
        .map((n) => `
          <div class="newsItem">
            <div class="t"><a href="${n.link}" target="_blank" rel="noopener noreferrer">${n.title}</a></div>
            <div class="m">${n.source ? n.source + " · " : ""}${n.pubDate}</div>
          </div>
        `)
        .join("");
    }

    async function loadNews() {
      const st = document.getElementById("newsStatus");
      const input = document.getElementById("rssQuery");

      setStatus(st, "Загружаю новости из кеша…");

      try {
        const r = await fetch("./news_cache.json", { cache: "no-store" });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const json = await r.json();

        // Подставим реальный запрос из кеша (если отличается от того, что в поле)
        if (json?.query && input) input.value = json.query;

        const items = Array.isArray(json?.items) ? json.items : [];
        setStatus(
          st,
          `Кеш обновлён: ${new Date(json.updatedAt).toLocaleString("ru-RU")}. Показано ${items.length} новостей.`,
          "ok"
        );
        renderNews(items);
      } catch (e) {
        setStatus(st, "Не удалось загрузить кеш новостей: " + (e?.message || e), "bad");
        document.getElementById("newsList").innerHTML = "";
      }
    }

    // ====== ИНИТ ======
    window.addEventListener("DOMContentLoaded", () => {
      initMap();

      document.getElementById("btnRefresh").addEventListener("click", loadForecast);
      const btnNews = document.getElementById("btnNews");
      btnNews.addEventListener("click", loadNews);

      // Автозагрузка
      loadForecast();
      loadNews(); // новости запрашиваем сразу при старте

      // Кнопку "Обновить новости" показываем только через 5 минут
      setTimeout(() => {
        btnNews.style.display = "inline-flex";
      }, 5 * 60 * 1000);
    });
  </script>
</body>
</html>
